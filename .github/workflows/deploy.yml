# This workflow deploys a Cloudflare Worker with D1 database integration.
# It supports production deployment on main branch pushes (updated on merges),
# preview deployments for all other branches on pushes, and preview deployments
# for pull requests targeting any branch. A cleanup job removes preview
# Workers and D1 databases when PRs are closed. The design avoids hardcoding
# D1 limits by using a try-create approach to detect limit breaches dynamically.

name: Deploy to Cloudflare Worker with D1

# Trigger the workflow on pushes to any branch and PR events
on:
  push:
    branches:
      - main  # Production deployment
      - '*'   # Preview deployments for all other branches
  pull_request:
    branches:
      - '*'  # Include all branches for PR previews
    types: [opened, synchronize, closed]  # Capture PR opening, updates, and closure

jobs:
  deploy:
    runs-on: ubuntu-latest  # Use the latest Ubuntu runner for consistency
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        # Ensures the latest version of the repo is available for deployment

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'  # Use Node.js 20 for compatibility with Wrangler 4

      - name: Install dependencies
        run: |
          npm install wrangler@4 --save-dev  # Install Wrangler version 4 for Worker management
          sudo apt update && sudo apt install -y jq  # Update package list and install jq for JSON processing

      - name: Set DEPLOY variable
        run: |
          # If this is a pull request, set DEPLOY to 'pr-<pr-number>' for preview mode
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "DEPLOY=pr-${{ github.event.pull_request.number }}" >> $GITHUB_ENV
          # For pushes to non-main branches, set DEPLOY to the branch name for preview mode
          elif [ "${{ github.ref_name }}" != "main" ]; then
            echo "DEPLOY=${{ github.ref_name }}" >> $GITHUB_ENV
          # For pushes to main, set DEPLOY to empty string for production mode
          elif [ "${{ github.ref_name }}" == "main" ]; then
            echo "DEPLOY=" >> $GITHUB_ENV
          # If none of the above conditions are met, throw an error for unexpected cases
          else
            echo "Error: Unexpected event or branch. No deployment mode defined for ${{ github.event_name }} on ${{ github.ref_name }}." >&2
            exit 1
          fi

      - name: Setup worker (Main Deployment)
        if: env.DEPLOY == ''  # Only run for production (push to main)
        run: |
          # Retrieve the worker name from repository variables
          WORKER_NAME=${{ vars.WORKER_NAME }}
          # Validate that WORKER_NAME is set to avoid deployment failures
          if [ -z "$WORKER_NAME" ]; then
            echo "Error: WORKER_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          # Generate wrangler.toml for the main Worker deployment
          echo "name = \"$WORKER_NAME\"" > wrangler.toml  # Set the Worker name
          echo "main = \"src/index.js\"" >> wrangler.toml  # Point to the entry script
          echo "compatibility_date = \"2025-10-24\"" >> wrangler.toml  # Ensure compatibility with current date

      - name: Setup worker (Preview Deployment)
        if: env.DEPLOY != ''  # Only run for previews (non-main branches or PRs)
        run: |
          # Retrieve the worker name and deployment environment
          WORKER_NAME=${{ vars.WORKER_NAME }}
          DEPLOY_ENV=${{ env.DEPLOY }}  # e.g., dev, feature-a, or pr-123
          DOMAIN=${{ vars.DOMAIN }}  # Custom domain, if set
          # Validate that WORKER_NAME is set
          if [ -z "$WORKER_NAME" ]; then
            echo "Error: WORKER_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          # Default to workers.dev if no custom domain is provided
          if [ -z "$DOMAIN" ]; then
            DOMAIN="workers.dev"
          fi
          # Generate wrangler.toml for the preview Worker with a unique name
          echo "name = \"${WORKER_NAME}-${DEPLOY_ENV}\"" > wrangler.toml  # e.g., my-worker-dev or my-worker-pr-123
          echo "main = \"src/index.js\"" >> wrangler.toml  # Point to the entry script
          echo "compatibility_date = \"2025-10-24\"" >> wrangler.toml  # Ensure compatibility
          echo "[[routes]]" >> wrangler.toml  # Define custom routes for preview
          echo "pattern = \"${DEPLOY_ENV}.preview.${DOMAIN}/*\"" >> wrangler.toml  # e.g., dev.preview.example.com/* or pr-123.preview.example.com/*
          echo "zone_name = \"${DOMAIN}\"" >> wrangler.toml  # Specify the domain for routing

      - name: Verify src/index.js exists
        run: |
          # Check if the main script file exists to prevent deployment failure
          if [ -f "src/index.js" ]; then
            echo "src/index.js found"
          else
            echo "Error: src/index.js not found" >&2
            exit 1
          fi

      - name: Create or get D1 database and bind
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Retrieve worker name and deployment environment
          WORKER_NAME=${{ vars.WORKER_NAME }}
          DEPLOY_ENV=${{ env.DEPLOY }}
          # Validate required variables
          if [ -z "$WORKER_NAME" ]; then
            echo "Error: WORKER_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          if [ -z "$CLOUDFLARE_API_TOKEN" ] || [ -z "$CLOUDFLARE_ACCOUNT_ID" ]; then
            echo "Error: CLOUDFLARE_API_TOKEN or CLOUDFLARE_ACCOUNT_ID is not set." >&2
            exit 1
          fi
          # Determine the database name based on deployment type
          if [ -z "$DEPLOY_ENV" ]; then
            DB_NAME="${WORKER_NAME}"  # Use the worker name for production
          else
            DB_NAME="${WORKER_NAME}-${DEPLOY_ENV}"  # Unique name for preview (e.g., my-worker-dev or my-worker-pr-123)
          fi
          BINDING_NAME=${{ vars.BINDING_NAME }}
          if [ -z "$BINDING_NAME" ]; then
            echo "Error: BINDING_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          npx wrangler whoami  # Verify authentication with Cloudflare
          DBS=$(npx wrangler d1 list --json)  # Fetch list of existing D1 databases
          DB_ID=$(echo "$DBS" | jq -r --arg name "$DB_NAME" '.[] | select(.name == $name) | .uuid')  # Find the database ID
          if [ -z "$DB_ID" ]; then
            echo "Attempting to create new D1 database \"$DB_NAME\""
            # Try to create the database and capture output, ignoring immediate failure
            OUTPUT=$(npx wrangler d1 create "$DB_NAME" 2>&1) || true
            if [[ $OUTPUT =~ "Database limit reached" ]]; then
              echo "Error: D1 database limit reached for this account. Please delete unused databases or upgrade your plan." >&2
              exit 1  # Fail the workflow with a clear error message
            elif [[ $OUTPUT =~ "failed" ]]; then
              echo "Error: Failed to create D1 database \"$DB_NAME\": $OUTPUT" >&2
              exit 1  # Fail with the raw error for debugging
            fi
            DBS=$(npx wrangler d1 list --json)  # Refresh the database list
            DB_ID=$(echo "$DBS" | jq -r --arg name "$DB_NAME" '.[] | select(.name == $name) | .uuid')  # Get the new ID
            if [ -z "$DB_ID" ]; then
              echo "Failed to determine database ID for \"$DB_NAME\" after creation" >&2
              exit 1  # Fail if ID retrieval fails
            fi
            echo "Created new D1 database with ID: $DB_ID"
          else
            echo "Using existing D1 database with ID: $DB_ID"
          fi
          if [ -z "$DB_ID" ]; then
            echo "Unable to determine a valid database ID for \"$DB_NAME\"." >&2
            exit 1  # Fail if no valid ID is found
          fi
          # Update wrangler.toml with the D1 binding if not already present
          if ! grep -q "database_id = \"$DB_ID\"" wrangler.toml; then
            echo "" >> wrangler.toml
            echo "[[d1_databases]]" >> wrangler.toml
            echo "binding = \"$BINDING_NAME\"" >> wrangler.toml
            echo "database_name = \"$DB_NAME\"" >> wrangler.toml
            echo "database_id = \"$DB_ID\"" >> wrangler.toml
            echo "D1 binding added/updated in wrangler.toml"
          else
            echo "D1 binding already present in wrangler.toml"
          fi
          {
            echo "DB_NAME=$DB_NAME"
            echo "DB_ID=$DB_ID"
          } >> $GITHUB_ENV  # Export variables for later steps

      - name: Apply D1 migrations
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          DB_NAME=${{ env.DB_NAME }}  # Use the dynamically set database name
          if ls migrations/*.sql >/dev/null 2>&1; then
            for file in migrations/*.sql; do
              echo "Applying migration: $file"
              if ! npx wrangler d1 execute "$DB_NAME" --file="$file" --remote; then
                echo "Failed to apply migration: $file" >&2
                exit 1  # Fail if a migration fails
              fi
            done
          else
            echo "No migration files found in migrations/ folder"  # Inform if no migrations exist
          fi
          echo "Verifying table creation"
          TABLES=$(npx wrangler d1 execute "$DB_NAME" --command="SELECT name FROM sqlite_master WHERE type='table'" --json --remote)
          if [ -n "$(echo "$TABLES" | jq -r '.[0].results[] | select(.name != null)')" ]; then
            echo "Tables confirmed in database"  # Confirm at least one table exists
          else
            echo "No tables found in database" >&2
            exit 1  # Fail if no tables are present post-migration
          fi

      - name: Deploy Worker
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}  # Authenticate with the API token
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}  # Specify the account ID
          environment: "${{ env.DEPLOY }}"  # Use the DEPLOY environment (empty for main, branch name or pr-<number> for previews)

      - name: Comment Preview URL on PR
        if: github.event_name == 'pull_request' && github.event.action != 'closed'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}  # Use GitHub token for API access
          script: |
            const prNumber = ${{ github.event.pull_request.number }};  // Get the PR number
            const domain = "${{ vars.DOMAIN || 'workers.dev' }}";  // Use custom domain or default to workers.dev
            const previewUrl = `https://${prNumber}.preview.${domain}`;  // Construct the preview URL
            await github.rest.issues.createComment({  // Post the comment on the PR
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `Preview Worker deployed at ${previewUrl}`
            });

  # Clean up preview Worker and D1 database when PR is closed
  cleanup-preview:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed'  # Trigger only on PR closure
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        # Checkout the repo to access any necessary scripts or configuration

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'  # Match the deployment environment

      - name: Install dependencies
        run: |
          npm install wrangler@4 --save-dev  # Install Wrangler for cleanup
          sudo apt update && sudo apt install -y jq  # Install jq for JSON parsing

      - name: Delete Preview Worker and D1 Database
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}  # Use the same token for cleanup
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}  # Get the PR number for naming
          PREVIEW_NAME="${{ vars.WORKER_NAME }}-pr-${PR_NUMBER}"  # Construct the preview Worker name
          PREVIEW_DB_NAME="${PREVIEW_NAME}"  # Match the D1 database name to the Worker
          # Authenticate with Cloudflare to ensure API access
          if npx wrangler whoami --json | jq -e '.success' > /dev/null 2>&1; then
            # List all Workers and check for the preview Worker
            WORKERS=$(npx wrangler workers list --json)
            if echo "$WORKERS" | jq -e --arg name "$PREVIEW_NAME" '.workers[] | select(.name == $name)' > /dev/null 2>&1; then
              echo "Deleting preview Worker: $PREVIEW_NAME"
              npx wrangler workers delete "$PREVIEW_NAME" --yes  # Delete the Worker without prompt
              echo "Preview Worker $PREVIEW_NAME deleted"
            else
              echo "Preview Worker $PREVIEW_NAME not found, skipping deletion"  # Avoid error if already deleted
            fi
            # List all D1 databases and check for the preview database
            D1_DBS=$(npx wrangler d1 list --json)
            if echo "$D1_DBS" | jq -e --arg name "$PREVIEW_DB_NAME" '.[] | select(.name == $name)' > /dev/null 2>&1; then
              echo "Deleting preview D1 database: $PREVIEW_DB_NAME"
              npx wrangler d1 delete "$PREVIEW_DB_NAME" --yes  # Delete the D1 database
              echo "Preview D1 database $PREVIEW_DB_NAME deleted"
            else
              echo "Preview D1 database $PREVIEW_DB_NAME not found, skipping deletion"
            fi
          else
            echo "Failed to authenticate with Cloudflare, skipping cleanup"  # Log failure and exit
            exit 1
          fi
