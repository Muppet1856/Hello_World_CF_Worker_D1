```yaml
# This workflow deploys a Cloudflare Worker with D1 database integration.
# It supports production deployment on main branch pushes and preview deployments
# for pull requests (PRs), each with an isolated D1 database. A cleanup job removes
# preview Workers and D1 databases when PRs are closed. The design avoids hardcoding
# D1 limits by using a try-create approach to detect limit breaches dynamically.

name: Deploy to Cloudflare Worker with D1

# Trigger the workflow on pushes to the main branch and PR events (open, sync, close)
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
    types: [opened, synchronize, closed]  # Capture PR opening, updates, and closure

jobs:
  deploy:
    runs-on: ubuntu-latest  # Use the latest Ubuntu runner for consistency
    steps:
      # Checkout the repository code to the runner
      - name: Checkout repository
        uses: actions/checkout@v4
        # Ensures the latest version of the repo is available for deployment

      # Set up Node.js environment for running Wrangler
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'  # Use Node.js 20 for compatibility with Wrangler 4

      # Install dependencies, including Wrangler CLI and jq for JSON parsing
      - name: Install dependencies
        run: |
          npm install wrangler@4 --save-dev  # Install Wrangler version 4 for Worker management
          sudo apt update && sudo apt install -y jq  # Update package list and install jq for JSON processing

      # Set the DEPLOY variable to determine production vs. preview mode
      - name: Set DEPLOY variable
        run: |
          # If this is a pull request, set DEPLOY to 'pr-<pr-number>' for preview mode
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "DEPLOY=pr-${{ github.event.pull_request.number }}" >> $GITHUB_ENV
          # For pushes to main, set DEPLOY to empty string for production mode
          else
            echo "DEPLOY=" >> $GITHUB_ENV
          fi

      # Configure wrangler.toml for the main (production) deployment
      - name: Setup worker (Main Deployment)
        if: env.DEPLOY == ''  # Only run for production (push to main)
        run: |
          # Retrieve the worker name from repository variables
          WORKER_NAME=${{ vars.WORKER_NAME }}
          # Validate that WORKER_NAME is set to avoid deployment failures
          if [ -z "$WORKER_NAME" ]; then
            echo "Error: WORKER_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          # Generate wrangler.toml for the main Worker deployment
          echo "name = \"$WORKER_NAME\"" > wrangler.toml  # Set the Worker name
          echo "main = \"src/index.js\"" >> wrangler.toml  # Point to the entry script
          echo "compatibility_date = \"2025-10-24\"" >> wrangler.toml  # Ensure compatibility with current date

      # Configure wrangler.toml for the preview deployment
      - name: Setup worker (Preview Deployment)
        if: env.DEPLOY != ''  # Only run for previews (pull requests)
        run: |
          # Retrieve the worker name and deployment environment
          WORKER_NAME=${{ vars.WORKER_NAME }}
          DEPLOY_ENV=${{ env.DEPLOY }}  # e.g., pr-123
          DOMAIN=${{ vars.DOMAIN }}  # Custom domain, if set
          # Validate that WORKER_NAME is set
          if [ -z "$WORKER_NAME" ]; then
            echo "Error: WORKER_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          # Default to workers.dev if no custom domain is provided
          if [ -z "$DOMAIN" ]; then
            DOMAIN="workers.dev"
          fi
          # Generate wrangler.toml for the preview Worker with a unique name
          echo "name = \"${WORKER_NAME}-${DEPLOY_ENV}\"" > wrangler.toml  # e.g., my-worker-pr-123
          echo "main = \"src/index.js\"" >> wrangler.toml  # Point to the entry script
          echo "compatibility_date = \"2025-10-24\"" >> wrangler.toml  # Ensure compatibility
          echo "[[routes]]" >> wrangler.toml  # Define custom routes for preview
          echo "pattern = \"${DEPLOY_ENV}.preview.${DOMAIN}/*\"" >> wrangler.toml  # e.g., pr-123.preview.example.com/*
          echo "zone_name = \"${DOMAIN}\"" >> wrangler.toml  # Specify the domain for routing

      # Verify the existence of the Worker entry script
      - name: Verify src/index.js exists
        run: |
          # Check if the main script file exists to prevent deployment failure
          if [ -f "src/index.js" ]; then
            echo "src/index.js found"
          else
            echo "Error: src/index.js not found" >&2
            exit 1
          fi

      # Manage D1 database creation and binding
      - name: Create or get D1 database and bind
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Retrieve worker name and deployment environment
          WORKER_NAME=${{ vars.WORKER_NAME }}
          DEPLOY_ENV=${{ env.DEPLOY }}
          # Validate required variables
          if [ -z "$WORKER_NAME" ]; then
            echo "Error: WORKER_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          if [ -z "$CLOUDFLARE_API_TOKEN" ] || [ -z "$CLOUDFLARE_ACCOUNT_ID" ]; then
            echo "Error: CLOUDFLARE_API_TOKEN or CLOUDFLARE_ACCOUNT_ID is not set." >&2
            exit 1
          fi
          # Determine the database name based on deployment type
          if [ -z "$DEPLOY_ENV" ]; then
            DB_NAME="${WORKER_NAME}"  # Use the worker name for production
          else
            DB_NAME="${WORKER_NAME}-${DEPLOY_ENV}"  # Unique name for preview (e.g., my-worker-pr-123)
          fi
          BINDING_NAME=${{ vars.BINDING_NAME }}
          if [ -z "$BINDING_NAME" ]; then
            echo "Error: BINDING_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          npx wrangler whoami  # Verify authentication with Cloudflare
          DBS=$(npx wrangler d1 list --json)  # Fetch list of existing D1 databases
          DB_ID=$(echo "$DBS" | jq -r --arg name "$DB_NAME" '.[] | select(.name == $name) | .uuid')  # Find the database ID
          if [ -z "$DB_ID" ]; then
            echo "Attempting to create new D1 database \"$DB_NAME\""
            # Try to create the database and capture output, ignoring immediate failure
            OUTPUT=$(npx wrangler d1 create "$DB_NAME" 2>&1) || true
            if [[ $OUTPUT =~ "Database limit reached" ]]; then
              echo "Error: D1 database limit reached for this account. Please delete unused databases or upgrade your plan." >&2
              exit 1  # Fail the workflow with a clear error message
            elif [[ $OUTPUT =~ "failed" ]]; then
              echo "Error: Failed to create D1 database \"$DB_NAME\": $OUTPUT" >&2
              exit 1  # Fail with the raw error for debugging
            fi
            DBS=$(npx wrangler d1 list --json)  # Refresh the database list
            DB_ID=$(echo "$DBS" | jq -r --arg name "$DB_NAME" '.[] | select(.name == $name) | .uuid')  # Get the new ID
            if [ -z "$DB_ID" ]; then
              echo "Failed to determine database ID for \"$DB_NAME\" after creation" >&2
              exit 1  # Fail if ID retrieval fails
            fi
            echo "Created new D1 database with ID: $DB_ID"
          else
            echo "Using existing D1 database with ID: $DB_ID"
          fi
          if [ -z "$DB_ID" ]; then
            echo "Unable to determine a valid database ID for \"$DB_NAME\"." >&2
            exit 1  # Fail if no valid ID is found
          fi
          # Update wrangler.toml with the D1 binding if not already present
          if ! grep -q "database_id = \"$DB_ID\"" wrangler.toml; then
            echo "" >> wrangler.toml
            echo "[[d1_databases]]" >> wrangler.toml
            echo "binding = \"$BINDING_NAME\"" >> wrangler.toml
            echo "database_name = \"$DB_NAME\"" >> wrangler.toml
            echo "database_id = \"$DB_ID\"" >> wrangler.toml
            echo "D1 binding added/updated in wrangler.toml"
          else
            echo "D1 binding already present in wrangler.toml"
          fi
          {
            echo "DB_NAME=$DB_NAME"
            echo "DB_ID=$DB_ID"
          } >> $GITHUB_ENV  # Export variables for later steps

      # Apply migrations to the D1 database
      - name: Apply D1 migrations
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          DB_NAME=${{ env.DB_NAME }}  # Use the dynamically set database name
          if ls migrations/*.sql >/dev/null 2>&1; then
            for file in migrations/*.sql; do
              echo "Applying migration: $file"
              if ! npx wrangler d1 execute "$DB_NAME" --file="$file" --remote; then
                echo "Failed to apply migration: $file" >&2
                exit 1  # Fail if a migration fails
              fi
            done
          else
            echo "No migration files found in migrations/ folder"  # Inform if no migrations exist
          fi
          echo "Verifying table creation"
          TABLES=$(npx wrangler d1 execute "$DB_NAME" --command="SELECT name FROM sqlite_master WHERE type='table'" --json --remote)
          if [ -n "$(echo "$TABLES" | jq -r '.result[] | select(.name != null)')" ]; then
            echo "Tables confirmed in database"  # Confirm at least one table exists
          else
            echo "No tables found in database" >&2
            exit 1  # Fail if no tables are present post-migration
          fi

      # Deploy the Worker to Cloudflare
      - name: Deploy Worker
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}  # Authenticate with the API token
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}  # Specify the account ID
          environment: "${{ env.DEPLOY }}"  # Use the DEPLOY environment (empty for production, pr-<number> for previews)

      # Comment the preview URL on the PR (except when closed)
      - name: Comment Preview URL on PR
        if: github.event_name == 'pull_request' && github.event.action != 'closed'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}  # Use GitHub token for API access
          script: |
            const prNumber = ${{ github.event.pull_request.number }};  // Get the PR number
            const domain = "${{ vars.DOMAIN || 'workers.dev' }}";  // Use custom domain or default to workers.dev
            const previewUrl = `https://${prNumber}.preview.${domain}`;  // Construct the preview URL
            await github.rest.issues.createComment({  // Post the comment on the PR
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `Preview Worker deployed at ${previewUrl}`
            });

  # Clean up preview Worker and D1 database when PR is closed
  cleanup-preview:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'closed'  # Trigger only on PR closure
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        # Checkout the repo to access any necessary scripts or configuration

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'  # Match the deployment environment

      - name: Install dependencies
        run: |
          npm install wrangler@4 --save-dev  # Install Wrangler for cleanup
          sudo apt update && sudo apt install -y jq  # Install jq for JSON parsing

      - name: Delete Preview Worker and D1 Database
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}  # Use the same token for cleanup
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}  # Get the PR number for naming
          PREVIEW_NAME="${{ vars.WORKER_NAME }}-pr-${PR_NUMBER}"  # Construct the preview Worker name
          PREVIEW_DB_NAME="${PREVIEW_NAME}"  # Match the D1 database name to the Worker
          # Authenticate with Cloudflare to ensure API access
          if npx wrangler whoami --json | jq -e '.success' > /dev/null 2>&1; then
            # List all Workers and check for the preview Worker
            WORKERS=$(npx wrangler workers list --json)
            if echo "$WORKERS" | jq -e --arg name "$PREVIEW_NAME" '.workers[] | select(.name == $name)' > /dev/null 2>&1; then
              echo "Deleting preview Worker: $PREVIEW_NAME"
              npx wrangler workers delete "$PREVIEW_NAME" --yes  # Delete the Worker without prompt
              echo "Preview Worker $PREVIEW_NAME deleted"
            else
              echo "Preview Worker $PREVIEW_NAME not found, skipping deletion"  # Avoid error if already deleted
            fi
            # List all D1 databases and check for the preview database
            D1_DBS=$(npx wrangler d1 list --json)
            if echo "$D1_DBS" | jq -e --arg name "$PREVIEW_DB_NAME" '.[] | select(.name == $name)' > /dev/null 2>&1; then
              echo "Deleting preview D1 database: $PREVIEW_DB_NAME"
              npx wrangler d1 delete "$PREVIEW_DB_NAME" --yes  # Delete the D1 database
              echo "Preview D1 database $PREVIEW_DB_NAME deleted"
            else
              echo "Preview D1 database $PREVIEW_DB_NAME not found, skipping deletion"
            fi
          else
            echo "Failed to authenticate with Cloudflare, skipping cleanup"  # Log failure and exit
            exit 1
          fi
```
