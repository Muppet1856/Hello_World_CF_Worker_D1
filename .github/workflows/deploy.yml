# Workflow Name and Purpose:
# This workflow automates the deployment of a Cloudflare Worker integrated with a D1 database.
# It handles three scenarios:
# 1. Production deployment: Triggered by pushes to the 'main' branch (e.g., after PR merges).
# 2. Branch preview deployments: Triggered by pushes or new branches that are not associated with an open PR.
# 3. PR preview deployments: Triggered by pull requests (PRs) targeting the 'main' branch.
# Preview URLs follow the format pr-<number>-<WORKER_NAME>.<subdomain>.workers.dev, where WORKER_NAME is set via repository variables.
# The workflow avoids hardcoding D1 database limits by using a try-create approach to detect limit breaches dynamically.

name: Deploy to Cloudflare Worker with D1

# Event Triggers:
# The workflow is triggered by:
# - Push events to any branch (production deploys only run for main; other branches deploy previews when no PR is open).
# - Pull request events (opened or synchronized) targeting the 'main' branch for preview deployments.
# - Branch create events so a preview can be provisioned immediately.
on:
  push:
    branches:
      - '**'
    paths-ignore:
      - '**/.github/**'
      - '**/README.md'
  pull_request:
    paths-ignore:
      - '**/.github/**'
      - '**/README.md'
    types: [opened, synchronize]
  create:
    branches:
      - '**'
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.event_name }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    # Job Configuration:
    # This job handles the deployment process for both production and preview environments.
    runs-on: ubuntu-latest  # Uses the latest Ubuntu runner for consistency and compatibility with required tools.
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Checkout repository
        # Purpose: Clones the repository to access the Worker code, configuration, and migration files.
        uses: actions/checkout@v4
        # Details: Uses the latest checkout action (v4) to ensure the most recent repository state is available.

      - name: Verify src/index.js exists
        # Purpose: Ensures the main Worker script exists to prevent deployment failures.
        run: |
          if [ -f "src/index.js" ]; then
            echo "src/index.js found"
          else
            echo "Error: src/index.js not found" >&2
            exit 1
          fi

      - name: Set DEPLOY variable
        # Purpose: Determines the deployment mode (production or preview) based on the event and branch.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          sanitize() {
            local raw="$1"
            local lower=$(echo "$raw" | tr '[:upper:]' '[:lower:]')
            local replaced=$(echo "$lower" | tr '/' '-')
            local cleaned=$(echo "$replaced" | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' | sed 's/^-//' | sed 's/-$//')
            if [ -z "$cleaned" ]; then
              cleaned="preview"
            fi
            echo "$cleaned"
          }
          # Logic for Pull Requests:
          # If the event is a pull request, sets DEPLOY to 'pr-<pr-number>' for preview mode (e.g., pr-24).
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            RAW_DEPLOY="pr-${{ github.event.pull_request.number }}"
            echo "DEPLOY=$(sanitize "$RAW_DEPLOY")" >> $GITHUB_ENV
          # Logic for Main Branch Pushes:
          # For pushes to main, sets DEPLOY to an empty string to indicate production mode.
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref_name }}" == "main" ]; then
            echo "DEPLOY=" >> $GITHUB_ENV
          # Logic for Branch Pushes (Preview deployments):
          # For pushes to non-main branches without open PRs, use a sanitized branch name for DEPLOY.
          elif [ "${{ github.event_name }}" == "push" ]; then
            if [ -z "${GITHUB_TOKEN:-}" ]; then
              echo "Error: GITHUB_TOKEN is not available for branch deployment detection." >&2
              exit 1
            fi
            API_URL="https://api.github.com/repos/${{ github.repository }}/pulls?head=${{ github.repository_owner }}:${{ github.ref_name }}&state=open"
            echo "Checking for open pull requests via ${API_URL}"
            RESPONSE=$(curl -sS -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "$API_URL")
            if [ -z "$RESPONSE" ]; then
              echo "Error: Empty response when querying pull requests for branch ${{ github.ref_name }}." >&2
              exit 1
            fi
            if echo "$RESPONSE" | grep -q '"message"'; then
              echo "Error: Unexpected GitHub API response when checking pull requests: $RESPONSE" >&2
              exit 1
            fi
            OPEN_COUNT=0
            if echo "$RESPONSE" | grep -q '"number"'; then
              OPEN_COUNT=$(echo "$RESPONSE" | grep -c '"number"')
              echo "Branch ${{ github.ref_name }} has $OPEN_COUNT open pull request(s); skipping direct branch deployment in favor of PR preview." >&2
              echo "DEPLOY_SKIP=true" >> $GITHUB_ENV
            else
              SANITIZED_BRANCH=$(sanitize "${{ github.ref_name }}")
              echo "DEPLOY=$SANITIZED_BRANCH" >> $GITHUB_ENV
              echo "NEWBRANCH=true" >> $GITHUB_ENV
            fi
          # Logic for Branch Creations:
          # For create events on branches, set DEPLOY using the new branch name so previews are provisioned immediately.
          elif [ "${{ github.event_name }}" == "create" ] && [ "${{ github.ref_type }}" == "branch" ]; then
            SANITIZED_BRANCH=$(sanitize "${{ github.ref_name }}")
            echo "DEPLOY=$SANITIZED_BRANCH" >> $GITHUB_ENV
            echo "NEWBRANCH=true" >> $GITHUB_ENV
          # Manual reruns through workflow_dispatch default to production deploys on the checked-out ref.
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "DEPLOY=" >> $GITHUB_ENV
          # Error Handling:
          # If none of the above conditions are met, logs an error and fails the workflow.
          else
            echo "Error: Unexpected event or branch. No deployment mode defined for ${{ github.event_name }} on ${{ github.ref_name }}." >&2
            exit 1
          fi

      - name: Skip branch deployment for PR-managed branch
        if: env.DEPLOY_SKIP == 'true'
        run: |
          echo "Branch has an open pull request; direct branch deployment will be skipped and the PR workflow will manage previews."

      - name: Set up Node.js
        if: env.DEPLOY_SKIP != 'true'
        # Purpose: Configures the Node.js environment required for running Wrangler commands.
        uses: actions/setup-node@v4
        with:
          node-version: '20'  # Specifies Node.js version 20, compatible with Wrangler 4.45.0.

      - name: Install dependencies
        if: env.DEPLOY_SKIP != 'true'
        # Purpose: Installs Wrangler and jq, which are needed for Worker deployment and JSON parsing.
        run: |
          # Installs Wrangler version 4 as a development dependency for managing Cloudflare Workers.
          npm install wrangler@4 --save-dev
          # Updates the package list and installs jq for processing JSON output from Wrangler and API calls.
          sudo apt update -qq && sudo apt install -y jq -qq

      - name: Setup worker (Main Deployment)
        if: env.DEPLOY_SKIP != 'true' && env.DEPLOY == ''  # Only runs for production deployments (when DEPLOY is empty).
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          WORKER_NAME=${{ vars.WORKER_NAME }}
          if [ -z "$WORKER_NAME" ]; then
            echo "Error: WORKER_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          echo "name = \"$WORKER_NAME\"" > wrangler.toml
          echo "main = \"src/index.js\"" >> wrangler.toml
          echo "compatibility_date = \"2025-10-25\"" >> wrangler.toml
          # Check for custom domain via workers/domains endpoint.
          API_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/workers/domains" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")
          echo "API Response (Domains): $API_RESPONSE"
          # Check if result array is empty
          RESULT_COUNT=$(echo "$API_RESPONSE" | jq '.result | length')
          if [ "$RESULT_COUNT" -eq 0 ]; then
            echo "No domains found for the account."
            DOMAIN=""
          else
            DOMAIN=$(echo "$API_RESPONSE" | jq -r '.result[0].hostname')
            if [ -z "$DOMAIN" ]; then
              echo "Failed to extract hostname."
            else
              echo "Extracted Domain: $DOMAIN"
            fi
          fi
          if [ -n "$DOMAIN" ]; then
            # Custom domain found, use it for routing.
            echo "[[routes]]" >> wrangler.toml
            echo "pattern = \"${DOMAIN}/*\"" >> wrangler.toml
            echo "zone_name = \"${DOMAIN}\"" >> wrangler.toml
            echo "WORKER_URL=${DOMAIN}" >> $GITHUB_ENV
          else
            # No custom domain, default to workers.dev and fetch subdomain.
            DOMAIN="workers.dev"
          fi
          if [ "$DOMAIN" = "workers.dev" ]; then
            API_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts/${{ secrets.CLOUDFLARE_ACCOUNT_ID }}/workers/subdomain" \
              -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
              -H "Content-Type: application/json")
            echo "API Response (Production): $API_RESPONSE"
            SUBDOMAIN=$(echo "$API_RESPONSE" | jq -r '.result.subdomain' 2>/dev/null || true)
            if [ -z "$SUBDOMAIN" ]; then
              echo "Error: Could not fetch workers.dev subdomain via API. Please ensure the subdomain is enabled in the Cloudflare dashboard." >&2
              exit 1
            fi
            echo "WORKER_URL=${WORKER_NAME}.${SUBDOMAIN}.workers.dev" >> $GITHUB_ENV
          elif [ "$DOMAIN" != "workers.dev" ] && [ -n "$DOMAIN" ]; then
            echo "WORKER_URL=${WORKER_NAME}.${DOMAIN}" >> $GITHUB_ENV
          else
            echo "Error: No Domain set, there is an error in the domain retreival logic." >&2
            exit 1
          fi

      - name: Setup worker (Preview Deployment)
        if: env.DEPLOY_SKIP != 'true' && env.DEPLOY != ''  # Only runs for preview deployments (when DEPLOY is set).
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          WORKER_NAME=${{ vars.WORKER_NAME }}
          if [ -z "$WORKER_NAME" ]; then
            echo "Error: WORKER_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          # Retrieves the deployment environment.
          DEPLOY_ENV=${{ env.DEPLOY }}
          PREVIEW_HOST="${DEPLOY_ENV}-${WORKER_NAME}"
          echo "Preview worker host derived from event: ${PREVIEW_HOST}"
          # Generates wrangler.toml for the preview Worker.
          echo "name = \"${PREVIEW_HOST}\"" > wrangler.toml
          echo "main = \"src/index.js\"" >> wrangler.toml
          echo "compatibility_date = \"2025-10-24\"" >> wrangler.toml
          # Check for custom domain via workers/domains endpoint.
          API_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/workers/domains" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")
          echo "API Response (Domains): $API_RESPONSE"
          # Check if result array is empty
          RESULT_COUNT=$(echo "$API_RESPONSE" | jq '.result | length')
          if [ "$RESULT_COUNT" -eq 0 ]; then
            echo "No domains found for the account."
            DOMAIN=""
          else
            DOMAIN=$(echo "$API_RESPONSE" | jq -r '.result[0].hostname')
            if [ -z "$DOMAIN" ]; then
              echo "Failed to extract hostname."
            else
              echo "Extracted Domain: $DOMAIN"
            fi
          fi
          if [ -n "$DOMAIN" ]; then
            # Custom domain found, use it for routing.
            echo "[[routes]]" >> wrangler.toml
            echo "pattern = \"${PREVIEW_HOST}.preview.${DOMAIN}/*\"" >> wrangler.toml
            echo "zone_name = \"${DOMAIN}\"" >> wrangler.toml
            echo "WORKER_URL=${PREVIEW_HOST}.preview.${DOMAIN}" >> $GITHUB_ENV
          else
            # No custom domain, default to workers.dev and fetch subdomain.
            DOMAIN="workers.dev"
            SUBDOMAIN_API_RESPONSE=$(curl -s -X GET "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/workers/subdomain" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json")
            echo "API Response (Subdomain): $SUBDOMAIN_API_RESPONSE"
            SUBDOMAIN=$(echo "$SUBDOMAIN_API_RESPONSE" | jq -r '.result.subdomain' 2>/dev/null || true)
            if [ -z "$SUBDOMAIN" ]; then
              echo "Error: Could not fetch workers.dev subdomain via API. Please ensure the subdomain is enabled in the Cloudflare dashboard." >&2
              exit 1
            fi
            echo "WORKER_URL=${PREVIEW_HOST}.${SUBDOMAIN}.workers.dev" >> $GITHUB_ENV
          fi

      - name: Create or get D1 database and bind
        # Purpose: Creates or retrieves a D1 database and binds it to the Worker in wrangler.toml.
        if: env.DEPLOY_SKIP != 'true'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}  # For Wrangler and API authentication.
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}  # For identifying the Cloudflare account.
          USE_PRODUCTION_DB_ON_PREVIEW: ${{ vars.USE_PRODUCTION_DB_ON_PREVIEW }} # For managing the production vs preview database
        run: |
          # Retrieves worker name and deployment environment.
          WORKER_NAME=${{ vars.WORKER_NAME }}
          DEPLOY_ENV=${{ env.DEPLOY }}
          # Validates required variables.
          if [ -z "$WORKER_NAME" ]; then
            echo "Error: WORKER_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          if [ -z "$CLOUDFLARE_API_TOKEN" ] || [ -z "$CLOUDFLARE_ACCOUNT_ID" ]; then
            echo "Error: CLOUDFLARE_API_TOKEN or CLOUDFLARE_ACCOUNT_ID is not set." >&2
            exit 1
          fi
          # Determines the database name based on deployment type.
          if [ -z "$DEPLOY_ENV" ] || [ "$USE_PRODUCTION_DB_ON_PREVIEW" = "true" ]; then
            DB_NAME="${WORKER_NAME}"  # Production: uses worker name.
          elif [ "$USE_PRODUCTION_DB_ON_PREVIEW" = "false" ] || [ -z "$USE_PRODUCTION_DB_ON_PREVIEW" ]; then
            DB_NAME="${DEPLOY_ENV}-${WORKER_NAME}"  # Preview: uses pr-<number>-<WORKER_NAME>.
          fi
          BINDING_NAME=${{ vars.BINDING_NAME }}  # Binding name for D1 database access.
          if [ -z "$BINDING_NAME" ]; then
            echo "Error: BINDING_NAME is not set. Please define it in GitHub repository variables." >&2
            exit 1
          fi
          # Verifies Cloudflare authentication.
          npx wrangler whoami
          # Fetches the list of existing D1 databases.
          DBS=$(npx wrangler d1 list --json)
          DB_ID=$(echo "$DBS" | jq -r --arg name "$DB_NAME" '.[] | select(.name == $name) | .uuid')
          # Creates a new database if it doesn't exist.
          if [ -z "$DB_ID" ]; then
            echo "Attempting to create new D1 database \"$DB_NAME\""
            OUTPUT=$(npx wrangler d1 create "$DB_NAME" 2>&1) || true
            # Checks for database limit errors.
            if [[ $OUTPUT =~ "Database limit reached" ]]; then
              echo "Error: D1 database limit reached for this account. Please delete unused databases or upgrade your plan." >&2
              exit 1
            elif [[ $OUTPUT =~ "failed" ]]; then
              echo "Error: Failed to create D1 database \"$DB_NAME\": $OUTPUT" >&2
              exit 1
            fi
            # Refreshes the database list and retrieves the new ID.
            DBS=$(npx wrangler d1 list --json)
            DB_ID=$(echo "$DBS" | jq -r --arg name "$DB_NAME" '.[] | select(.name == $name) | .uuid')
            if [ -z "$DB_ID" ]; then
              echo "Failed to determine database ID for \"$DB_NAME\" after creation" >&2
              exit 1
            fi
            echo "Created new D1 database with ID: $DB_ID"
          else
            echo "Using existing D1 database with ID: $DB_ID"
          fi
          if [ -z "$DB_ID" ]; then
            echo "Unable to determine a valid database ID for \"$DB_NAME\"." >&2
            exit 1
          fi
          # Adds D1 binding to wrangler.toml if not already present.
          if ! grep -q "database_id = \"$DB_ID\"" wrangler.toml; then
            echo "" >> wrangler.toml
            echo "[[d1_databases]]" >> wrangler.toml
            echo "binding = \"$BINDING_NAME\"" >> wrangler.toml
            echo "database_name = \"$DB_NAME\"" >> wrangler.toml
            echo "database_id = \"$DB_ID\"" >> wrangler.toml
            echo "D1 binding added/updated in wrangler.toml"
          else
            echo "D1 binding already present in wrangler.toml"
          fi
          # Exports database variables for later steps.
          {
            echo "DB_NAME=$DB_NAME"
            echo "DB_ID=$DB_ID"
          } >> $GITHUB_ENV

      - name: Apply D1 migrations
        # Purpose: Applies SQL migration files to the D1 database and verifies table creation.
        if: env.DEPLOY_SKIP != 'true'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        run: |
          DB_NAME=${{ env.DB_NAME }}  # Uses the dynamically set database name.
          # Checks for SQL migration files in the migrations/ directory.
          if ls migrations/*.sql >/dev/null 2>&1; then
            for file in migrations/*.sql; do
              echo "Applying migration: $file"
              # Executes each migration file remotely on the D1 database.
              if ! npx wrangler d1 execute "$DB_NAME" --file="$file" --remote; then
                echo "Failed to apply migration: $file" >&2
                exit 1
              fi
            done
          else
            echo "No migration files found in migrations/ folder"
          fi
          # Verifies that tables were created in the database.
          echo "Verifying table creation"
          TABLES=$(npx wrangler d1 execute "$DB_NAME" --command="SELECT name FROM sqlite_master WHERE type='table'" --json --remote)
          if [ -n "$(echo "$TABLES" | jq -r '.[0].results[] | select(.name != null)')" ]; then
            echo "Tables confirmed in database"
          else
            echo "No tables found in database" >&2
            exit 1
          fi

      - name: Deploy Worker
        # Purpose: Deploys the Worker to Cloudflare using the wrangler-action.
        if: env.DEPLOY_SKIP != 'true'
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}  # Authenticates with Cloudflare.
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}  # Specifies the account for deployment.

      - name: Debug Variables
        if: github.event_name == 'pull_request'
        run: |
          echo "WORKER_URL: ${{ env.WORKER_URL }}"
          echo "PR Number: ${{ github.event.pull_request.number }}"
          echo "Event Name: ${{ github.event_name }}"
          echo "Event Action: ${{ github.event.action }}"

      - name: Comment Preview URL on PR
        # Purpose: Posts the preview Worker URL as a comment on the PR.
        if: github.event_name == 'pull_request' && github.event.action != 'closed'  # Only runs for non-closed PRs.
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}  # Uses GitHub token for API access.
          script: |
            const prNumber = ${{ github.event.pull_request.number }};
            const previewUrl = "${{ env.WORKER_URL }}";
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `Preview Worker deployed at https://${previewUrl}`
            });
